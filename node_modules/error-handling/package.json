{
  "_args": [
    [
      "error-handling",
      "D:\\WORK\\NAE"
    ]
  ],
  "_from": "error-handling@*",
  "_id": "error-handling@1.0.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/error-handling",
  "_npmUser": {
    "email": "kdunsmore@virtuoz.com",
    "name": "kdunsmore"
  },
  "_npmVersion": "1.1.62",
  "_phantomChildren": {},
  "_requested": {
    "name": "error-handling",
    "raw": "error-handling",
    "rawSpec": "",
    "scope": null,
    "spec": "*",
    "type": "range"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/error-handling/-/error-handling-1.0.0.tgz",
  "_shasum": "96f96407dc79d733d17973b5a07d9731f3dffd71",
  "_shrinkwrap": null,
  "_spec": "error-handling",
  "_where": "D:\\WORK\\NAE",
  "contributors": [
    {
      "name": "Kevan Dunsmore",
      "email": "kdunsmore@virtuoz.com"
    }
  ],
  "dependencies": {
    "futures": "2.1.0"
  },
  "description": "error-handling ==============",
  "devDependencies": {
    "chai": "1.3.0",
    "mocha": "1.6.0",
    "xunit-file": "0.0.1"
  },
  "directories": {},
  "dist": {
    "shasum": "96f96407dc79d733d17973b5a07d9731f3dffd71",
    "tarball": "http://registry.npmjs.org/error-handling/-/error-handling-1.0.0.tgz"
  },
  "homepage": "https://github.com/VirtuOz/node-error-handling",
  "main": "./index.js",
  "maintainers": [
    {
      "name": "kdunsmore",
      "email": "kdunsmore@virtuoz.com"
    }
  ],
  "name": "error-handling",
  "optionalDependencies": {},
  "readme": "error-handling\n==============\n\nAt VirtuOz we love [Futures](https://github.com/coolaj86/futures).  But when you use it, you end up with lots,\nand I do mean *lots*, of boilderplate error-handling code.  Like this:\n\n    var Future = require('futures').future;\n    .\n    .\n    .\n    function doSomethingInTheFuture()\n    {\n        var future = new Future()\n\n        someAsynchronousOperation(function(err, result)\n        {\n            if (err)\n            {\n                future.fulfill(err);\n                return;\n            }\n\n            // Now do something else.\n            somethingElseAsynchronous(function(err, anotherResult)\n            {\n                if (err)\n                {\n                    future.fulfill(err);\n                    return;\n                }\n\n                var myOperationResult = result + anotherResult;\n                future.fulfill(undefined, myOperationResult);\n            });\n\n        });\n        return future;\n    }\n\n\n    var futureResult = doSomethingInTheFuture();\n    futureResult.when(function(err, result))\n    {\n        // Code to handle async return.\n    });\n\nAs you can see, the code to handle errors is boring and repetitive.  Enter this module.  It will save you time.  And\nmake you happy.  Like this:\n\n    var Future = require('futures').future;\n    var eh = require('vnodelib').load('error-handling');\n    .\n    .\n    .\n    function doSomethingInTheFuture()\n    {\n        var future = new Future()\n        var wrap = eh.createWrapperFromFuture(future);\n\n        someAsynchronousOperation(wrap(function(result)\n        {\n            // Now do something else.\n            somethingElseAsynchronous(wrap(function(anotherResult)\n            {\n                var myOperationResult = result + anotherResult;\n                future.fulfill(undefined, myOperationResult);\n            }));\n\n        }));\n        return future;\n    }\n\n\n    var futureResult = doSomethingInTheFuture();\n    futureResult.when(function(err, result))\n    {\n        // Code to handle async return.\n    });\n\nSee?  Lots of boilerplate cut out of the picture.\n\nOf course, you needn't just use error-handling with Future.  You can do it like this:\n\n    var eh = require('vnodelib').load('error-handling');\n    .\n    .\n    .\n    function doSomethingInTheFuture(callback)\n    {\n        var wrap = eh.createWrapperFromCallback(function(err)\n        {\n            // Custom logging or whatever goes here.\n\n            // Tell the callback that something really bad happened.\n            callback(err);\n        });\n\n        someAsynchronousOperation(wrap(function(result)\n        {\n            // Now do something else.\n            somethingElseAsynchronous(wrap(function(anotherResult)\n            {\n                var myOperationResult = result + anotherResult;\n                callback(undefined, myOperationResult);\n            }));\n\n        }));\n        return future;\n    }\n\nIf you're still not convinced, try using Future or even the standard async pattern where errors are involved, for\nanything other than a trivial example.  You'll be sad.  Then you can come back here.  And be happy.",
  "scripts": {
    "clean": "rm -rf target; rm -f xunit.xml",
    "test": "node_modules/mocha/bin/_mocha test/*_test.js --ignore-leaks -t 20000 --reporter spec",
    "test-jenkins": "node_modules/mocha/bin/_mocha test/*_test.js --ignore-leaks -t 20000 --reporter xunit-file"
  },
  "version": "1.0.0"
}
